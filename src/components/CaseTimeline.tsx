import React, { useEffect, useState } from "react";
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Separator } from "@/components/ui/separator";
import { supabase } from "@/integrations/supabase/client";
import { toast } from "sonner";
import { format } from "date-fns"; // Corrected import
import { Bot } from "lucide-react";

interface TimelineEvent {
  id: string;
  timestamp: Date;
  title: string;
  description: string;
  type: 'activity' | 'theory_update' | 'auto_generated_event';
}

interface CaseTimelineProps {
  caseId: string;
}

export const CaseTimeline: React.FC<CaseTimelineProps> = ({ caseId }) => {
  const [timelineEvents, setTimelineEvents] = useState<TimelineEvent[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchTimelineData = async () => {
    setLoading(true);
    setError(null);

    try {
      // Fetch agent activities
      const { data: activitiesData, error: activitiesError } = await supabase
        .from("agent_activities")
        .select("id, timestamp, agent_name, activity_type, content")
        .eq("case_id", caseId);

      if (activitiesError) throw activitiesError;

      const activityEvents: TimelineEvent[] = (activitiesData || []).map(activity => ({
        id: activity.id,
        timestamp: new Date(activity.timestamp),
        title: `${activity.agent_name}: ${activity.activity_type}`,
        description: activity.content,
        type: 'activity',
      }));

      // Fetch case theory updates
      const { data: theoryData, error: theoryError } = await supabase
        .from("case_theories")
        .select("id, last_updated, status")
        .eq("case_id", caseId)
        .single();

      let theoryEvents: TimelineEvent[] = [];
      if (theoryData) {
        theoryEvents.push({
          id: theoryData.id + '-theory-update',
          timestamp: new Date(theoryData.last_updated),
          title: `Case Theory Updated`,
          description: `Status: ${theoryData.status}.`,
          type: 'theory_update',
        });
      } else if (theoryError && theoryError.code !== 'PGRST116') {
        throw theoryError;
      }

      // Fetch auto-generated timeline events from case_insights
      const { data: autoEventsData, error: autoEventsError } = await supabase
        .from("case_insights")
        .select("id, timestamp, title, description")
        .eq("case_id", caseId)
        .eq("insight_type", "auto_generated_event");

      if (autoEventsError) throw autoEventsError;

      const autoGeneratedEvents: TimelineEvent[] = (autoEventsData || []).map(event => ({
        id: event.id,
        timestamp: new Date(event.timestamp),
        title: event.title,
        description: event.description,
        type: 'auto_generated_event',
      }));

      // Combine and sort events by timestamp
      const combinedEvents = [...activityEvents, ...theoryEvents, ...autoGeneratedEvents].sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());
      setTimelineEvents(combinedEvents);

    } catch (err: any) {
      console.error("Error fetching timeline data:", err);
      setError("Failed to load timeline data. Please try again.");
      toast.error("Failed to load timeline data.");
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (!caseId) {
      setError("No case ID provided for timeline.");
      setLoading(false);
      return;
    }

    fetchTimelineData();

    // Real-time subscription for all relevant tables
    const channel = supabase
      .channel(`timeline_for_case_${caseId}`)
      .on('postgres_changes', { event: '*', schema: 'public', table: 'agent_activities', filter: `case_id=eq.${caseId}` }, () => fetchTimelineData())
      .on('postgres_changes', { event: '*', schema: 'public', table: 'case_theories', filter: `case_id=eq.${caseId}` }, () => fetchTimelineData())
      .on('postgres_changes', { event: '*', schema: 'public', table: 'case_insights', filter: `case_id=eq.${caseId}` }, () => fetchTimelineData())
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [caseId]);

  if (loading) {
    return <div className="text-center py-8">Loading timeline...</div>;
  }

  if (error) {
    return <div className="text-center py-8 text-red-500">{error}</div>;
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle>Case Timeline</CardTitle>
        <CardDescription>Key events and updates in the case analysis.</CardDescription>
      </CardHeader>
      <CardContent>
        <ScrollArea className="h-[300px] pr-4">
          {timelineEvents.length > 0 ? (
            <div className="relative pl-6 border-l-2 border-gray-200 dark:border-gray-700">
              {timelineEvents.map((event) => (
                <div key={event.id} className="mb-8 last:mb-0">
                  <div className={`absolute -left-2.5 mt-1 h-4 w-4 rounded-full border-2 border-background ${event.type === 'auto_generated_event' ? 'bg-blue-500' : 'bg-primary'}`} />
                  <div className="ml-4">
                    <p className="text-xs text-muted-foreground">
                      {format(event.timestamp, "MMM dd, yyyy HH:mm")}
                    </p>
                    <h3 className="font-semibold text-foreground mt-1 flex items-center">
                      {event.type === 'auto_generated_event' && <Bot className="h-4 w-4 mr-2 text-blue-500" />}
                      {event.title}
                    </h3>
                    <p className="text-sm text-muted-foreground">{event.description}</p>
                  </div>
                </div>
              ))}
            </div>
          ) : (
            <p className="text-center py-4 text-muted-foreground">
              No timeline events yet. Analysis will generate events here.
            </p>
          )}
        </ScrollArea>
      </CardContent>
    </Card>
  );
};